<!DOCTYPE html>
<html>
  <head>
    <style>
    #scrollUp
    {
    position: fixed;
    bottom : 10px;
    right: -400px;
    opacity: 0.30;
    }
    </style>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
 
    <script>
                jQuery(function(){
                    $(function () {
                        $(window).scroll(function () {
                            if ($(this).scrollTop() > 200 ) { 
                                $('#scrollUp').css('right','10px');
                            } else { 
                                $('#scrollUp').removeAttr( 'style' );
                            }
 
                        });
                    });
                });
    </script>
    <link rel="stylesheet"  href="css/prism.css" />
    <script src="js/prism.js"></script>
    <meta charset="utf-8">
    <title>VÉHICULE AUTONOME</title>
    <link rel="stylesheet" href="css/style.css">
  </head>
  <body>
    <header>
      <h1>VÉHICULE AUTONOME</h1>
      <nav>
        <ul>
          <li><a href="#obj">OBJECTIF</a></li>
          <li><a href="#meo">MISE EN OEUVRE</a></li>
          <li><a href="#pcp">PRINCIPE</a></li>
          <li><a href="#ccpt">CONCEPTION</a></li>
          <li><a href="#dmstr">DÉMONSTRATION</a></li>
          <li><a href="#cdg">CODAGE</a></li>
        </ul>
      </nav>
    </header>
    <main>
        <center style="color:#515151"><FONT size="6pt"><FONT face="Georgia"><br>Bienvenue sur mon site de robotique !</FONT></FONT></center>
        <center><i><br><br><br>Depuis un certain temps, les constructeurs automobiles nous promettent des véhicules entièrement autonomes ! Ils viendraient nous chercher au pied de notre porte pour nous emmener à destination sans aucune action de notre part. C’est cette vision futuriste des choses qui m’a poussé à choisir ce sujet. Les nouvelles technologies améliorent les villes de jour en jour en y introduisant une autonomie bien marquée. C’est donc sur ce principe que j'ai eu l'envie de concevoir ce projet !</i></center>
      <section id="obj">
        <h2 id="titre1" style="color:#515151"><br><br>L'Objectif de mon projet : En quoi ça consiste</h2>
        <p>
Mon objectif est de réaliser un véhicule autonome capable de parcourir le plus court trajet entre deux points sur un plan hippodamien.
Sur un circuit hippodamien composé de 16 sommets reliés entre eux sous forme de matrice 4x4, un véhicule composé de plusieurs capteurs sera asservi en position afin de maintenir la bonne direction entre deux sommets. De plus, le véhicule sera également équipé d’un autre capteur dans l’optique d’asservir le système en distance. Par ailleurs, le calcul du plus court trajet entre deux points sera déterminé par l’algorithme de Dijkstra à l’aide d’un dictionnaire traduisant le circuit hippodamien souhaité.
         </p>
      </section>
      <section id="meo">
        <h2 id="titre2" style="color:#515151"><br>La mise en oeuvre : Le contexte de création</h2>
        <p>Afin de pouvoir modéliser ce concept, il faut impérativement que la ville soit un plan hippodamien. Un plan hippodamien est, en urbanisme, un type d'organisation de la ville dans lequel les rues sont rectilignes et se croisent en angle droit, créant des îlots de forme carrée ou rectangulaire. De très nombreuses villes avec un tel plan existent dans le monde entier. Exemple : New York, Barcelone, Pékin, Manhattan,... Ainsi, ce véhicule autonome pourrait remplacer les bus, taxis ou encore faire guise de véhicule personnel.<br><br>
        </p>
        <div style="text-align: center;">
            <img src="img/barcelone.jpg" height="500" width="700" alt="Description de l'image">
        </div>
        <center><i>Photographie représentative du plan hippodamien de Barcelone, ville d’Espagne.</i></center>


      </section>
      <section id="pcp">
        <h2 id="titre3" style="color:#515151"><br>Le principe : Comment ça marche ?</h2>
        <p>Le robot fonctionne de la manière suivante:</p>
        <ul>
          <li>L'utilisateur doit entrer le sommet de départ</li>
          <li>--------------------------------------------------arrivé</li>
        </ul>
        <p>Le programme du robot renverra alors un graph du circuit avec les positions de départ (carré blanc), d'arrivée (croix blanche) ainsi que l'itinéraire en rouge:<br><br>
        </p>
        <div style="text-align: center;">
            <img src="img/principe_img1.png" height="475" width="475" alt="Description de l'image">
        </div>
        <center><i>Graphe représentant un plan hippodamien composé de 16 sommets.</i></center>
        <p><br>Ici on a choisi le sommmet de départ "B" et le sommet d'arrivé "H".<br>Le programme du robot à ainsi trouvé le chemin entre ces deux sommets dont la longueur est la plus faible des chemins possible. La longueur d'un chemin est égale à la somme des poids de chacune des arêtes qui le constituent. Pour notre exemple, le plus court chemin : B-E-O-A-F-H à une longueur de 37. Dans la vie pratique, le poids sur les arêtes pourrait être le temps de trajet entre deux sommets. On utilisera ce graphe pour la démonstration.
        </p>
      </section>
      <section id="ccpt">
        <h2 id="titre4" style="color:#515151"><br>La conception : De quoi c'est fait ?</h2>
        <p>Le véhicule est constitué de:</p>
        <ul>
          <li>Chassis (2x roues motrice - motoreducteurs CC/roue folle/interrupteur/coupleur de piles)</li>
          <li>Capteur de distance à ultrasons HC-SR04</li>
          <li>2 capteurs infrarouges</li>
          <li>Servomoteur</li>
          <li>Buzzer</li>
          <li>Compas magnétique numérique QMC5883L</li>
          <li>Microcontroleur Arduino uno</li>
          <li>Pont-H L293D</li>
          <li>Breadboard</li>
          <li>Cable jumper</li>
        </ul>
        <p><br>Voici un schéma des branchements effectués :</p>
        <div style="text-align: center;">
            <img src="img/Branchement.png" height="500" width="700" alt="Description de l'image">
        </div>
        <p><br>Après branchement :</p>
        <div style="display:flex;">
            <img src="img/dessus.jpg" height="500" width="700" style="flex:1;margin-right:10px;">
            <img src="img/dessous.jpg" height="500" width="700" style="flex:1;">
        </div>
      </section>
      <section id="dmstr">
        <h2 id="titre6" style="color:#515151"><br>Démonstration</h2>
        <div style="text-align:center;">
            <iframe width="800" height="600" src="https://www.youtube.com/embed/8mwjeWnUlJM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
      </section>
      <section id="cdg">
        <h2 id="titre5" style="color:#515151"><br>Le codage : La clé du projet !</h2>
        <p>Ce projet a été réalisé dans le language Python car c'est ce langage qui est au programme de CPGE. Pour ce faire, il a fallu transverser un code arduino dans l'Arduino uno. Ce code sert à "traduire" en quelque sorte le langage Python en langage Arduino. De plus, il faut télécharger le module <a href=https://github.com/MrYsLab/pymata4>pymata4</a> écrit par Alan Yorinks afin de controler la carte arduino à l'aide de nombreuse fonctions. Malheureusement, un cable entre la carte et l'ordinateur est nécessaire... À noter que pour executer le script complet, on doit utiliser un environnement de developpement qui ne bloque pas le code à l'affichage d'un graphe. Exemple : Spyder, ...<br> </p>
        <h3 id="sous-titre0" style="color:#515151"><br>Modélisation du graphe</h3>
        <p>Tout d'abord, le graphe doit être modéliser sous la forme d'un dictionnaire Python. En effet, il est possible de représenter un graphe avec Python en utilisant un dictionnaire qui associe à chaque sommet un sous-dictionnaire composé de ses sommets adjacents et de la pondération de l'arête incidente (<a href=https://math.univ-lyon1.fr/irem/Formation_ISN/formation_parcours_graphes/dijkstra/2_python_dico.html>source</a>). Pour la démonstration, on  a utiliser le graphe suivant :</p>
        <pre class="line-numbers"><code class="language-python">
    G={'A':{'F':10,'C':4,'P':90,'O':3},
       'B':{'E':6,'D':24,'I':7},
       'C':{'N':4,'D':1,'A':4,'M':9},
       'D':{'C':1,'O':16,'G':34,'B':24},
       'E':{'J':14,'O':14,'B':6},
       'F':{'M':11,'H':4,'A':10},
       'G':{'N':76,'D':34,'I':12},
       'H':{'P':19,'F':4},
       'I':{'G':12,'B':7},
       'J':{'L':8,'E':14},
       'K':{'N':2,'M':68},
       'L':{'O':5,'J':8,'P':23},
       'M':{'F':11,'K':68,'C':9},
       'N':{'K':2,'G':76,'C':4},
       'O':{'A':3,'D':16,'E':14,'L':5},
       'P':{'H':19,'A':90,'L':23}}
    </code></pre>
    <h3 id="sous-titre1" style="color:#515151"><br>Sommets de départ et d'arrivée</h3>
        <p>Le script interroge l'utilisateur sur le sommet de départ et d'arrivé :</p>
        <pre class="line-numbers"><code class="language-python">
def depart():
    '''
    Entrée: Rien
    Sortie: str
    But: Retourner le sommet de départ
    '''
    entre=input("Quelle est votre sommet de départ ? ") #Questionner l'utilisateur sur le sommet de départ
    while (entre not in G): #Répéter la question jusqu'à ce que l'utilisateur entre un sommet qui est présent dans le dictionnaire 
        entre=input("\nQuelle est votre sommet de départ ? ")
    return entre #Retourne le sommet de départ

def arrivée():
    '''
    Entrée: Rien
    Sortie: str
    But: Retourner le sommet de d'arrivée
    '''
    arrivé=input("\nQuelle est votre sommet d'arrivée ? ") #Questionner l'utilisateur sur le sommet d'arrivée
    while (arrivé not in G): #Répéter la question jusqu'à ce que l'utilisateur entre un sommet qui est présent dans le dictionnaire 
        arrivé=input("\nQuelle est votre sommet d'arrivée ? ")
    return arrivé #Retourne le sommet d'arrivée
</code></pre>
    <h3 id="sous-titre2" style="color:#515151"><br>Algorithme de Dijsktra</h3>
    <p>Afin de réaliser le plus court trajet, le script doit éxécuter le célèbre algorithme de Dijsktra afin d'obtenir une liste comprenant les sommets parcouru (du sommet de départ au sommet d'arrivée) :</p>
    <pre class="line-numbers"><code class="language-python">
#Variables-Dijkstra#
chemin=[]

def moore_dijkstra_1(G, s):
    """
     FONCTION QUI CALCULE TOUS LES PLUS COURTS CHEMINS DE L'ENTREE A CHACUN DES SOMMETS
    """
    inf = sum(sum(G[sommet][i] for i in G[sommet]) for sommet in G) + 1
    global s_explore
    global s_a_explorer
    s_explore = {s : [0, [s]]}
    s_a_explorer = {j : [inf, ""] for j in G if j != s}
    for suivant in G[s]:
        s_a_explorer[suivant] = [G[s][suivant], s]

    while s_a_explorer and any(s_a_explorer[k][0] < inf for k in s_a_explorer):
        s_min = min(s_a_explorer, key = s_a_explorer.get)
        longueur_s_min, precedent_s_min = s_a_explorer[s_min]
        for successeur in G[s_min]:
            if successeur in s_a_explorer:
                dist = longueur_s_min + G[s_min][successeur]
                if dist < s_a_explorer[successeur][0]:
                    s_a_explorer[successeur] = [dist, s_min]
        s_explore[s_min] = [longueur_s_min, s_explore[precedent_s_min][1] + [s_min]]
        del s_a_explorer[s_min]

    return s_explore


def affichage(G, entree, sortie):
    """
    FONCTION D'AFFICHAGE DU PLUS COURT CHEMIN ENTRE L'ENTREE ET LA SORTIE DU GRAPHE
    """
    moore_dijkstra_1(G, entree)
    '''

    print("Dans le graphe d\'origine {} dont les arcs sont :".format(entree))
    for k in MonGraphe:
        print(k, ":", MonGraphe[k])
    '''
    print()

    for k in s_explore:
        if sortie == k:
            print("Le plus court chemin menant de {} à {} est ".format(entree, sortie), end="")
            print("->".join(s_explore[k][1]))
            chemin.append(s_explore[k][1])
            print("Son poids est égal à {}".format(s_explore[k][0]))

    for k in s_a_explorer:
        if sortie == k:
            print("Il n\'existe aucun chemin de {} à {}".format(entree, sortie))
</code></pre>
    <h3 id="sous-titre3" style="color:#515151"><br>Tracer du graphe</h3>
    <p>Le tracer du graphe se réalise en 2 étapes. Premièrement, à partir du dictionnaire G traduisant le graphe, le script doit réussir à modéliser une liste des sommets dans un le meme ordre que notre plan hippodamien, ainsi qu'un liste des poids. Deuxièment, le script trace 16 carrés noirs (sommets) reliés entre eux. À partir des deux listes précédentes, le script pourra donc rajouter les noms des sommets ainsi que les poids sur les liens correspondants. De plus, avec les fonctions depart() et arrivée(). Le script pourra rajouter un carré blanc sur la position initialle du véhicule et une croix sur le sommet d'arrivée. Par ailleurs, à l'aide de l'itinéraire réalisé par l'algortithme de Dijsktra, le script tracera la route à suivre en rouge : 
    <pre class="line-numbers"><code class="language-python">
import numpy as np
from matplotlib.patches import Rectangle
import matplotlib.pyplot as plt

Lmatgraph=[]
Lpoids=[]

def matrice(G):
    '''
    Entrée: Dictionnaire G
    Sortie: Rien
    But: Ajoute les listes des sommets/poids voulues dans deux listes initialiser en dehors de la fonction (afin de réutiliser celles-ci sans refaire le script)
    '''
    ###Le principe est de rechercher dans le dictionnaire un sommet ayant deux voisins et de placer ses voisins, puis les voisins de ses voisins, etc jusqu'à obtenir la liste complète
    ###De même pour la liste des poids
    matgraph=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    nbrvois=[]
    poids=[]
    couleur=["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P"]
    for cle,valeur in G.items():
        nbrvois.append(len(valeur))
    sommet0=couleur[nbrvois.index(2)]
    matgraph[0]=sommet0
    for cle,valeur in G.items():
        if cle==sommet0:
            for k,j in valeur.items():
                sommet1=k
                matgraph[1]=sommet1
                break
    for cle,valeur in G.items():
        if cle==sommet1:
            for k,j in valeur.items():
                if len(G[k])==3:
                    sommet2=k
                    break
    matgraph[2]=sommet2
    for cle,valeur in G.items():
        if cle==sommet2:
            for k,j in valeur.items():
                if len(G[k])==2:
                    sommet3=k
                    break
    matgraph[3]=sommet3
    for cle,valeur in G.items():
        if cle==sommet0:
            for k,j in valeur.items():
                if (k!=sommet1):
                    sommet4=k
                    break
    matgraph[4]=sommet4
    for cle,valeur in G.items():
        if cle==sommet4:
            for k,j in valeur.items():
                if len(G[k])==4:
                    sommet5=k
                    break
    matgraph[5]=sommet5
    for cle,valeur in G.items():
        if cle==sommet5:
            for k,j in valeur.items():
                if len(G[k])==4:
                    if (sommet2 in G[k]):
                        sommet6=k
                        break
    matgraph[6]=sommet6
    for cle,valeur in G.items():
        if cle==sommet6:
            for k,j in valeur.items():
                if len(G[k])==3:
                    if (sommet1 not in G[k]):
                        sommet7=k
                        break
    matgraph[7]=sommet7
    for cle,valeur in G.items():
        if cle==sommet4:
            for k,j in valeur.items():
                if (k!=sommet0) and (k!=sommet5):
                    sommet8=k
                    break
    matgraph[8]=sommet8
    for cle,valeur in G.items():
        if cle==sommet8:
            for k,j in valeur.items():
                if len(G[k])==4:
                    sommet9=k
                    break
    matgraph[9]=sommet9
    for cle,valeur in G.items():
        if cle==sommet9:
            for k,j in valeur.items():
                if len(G[k])==4:
                    if (k!=sommet5):
                        sommet10=k
                        break
    matgraph[10]=sommet10
    for cle,valeur in G.items():
        if cle==sommet10:
            for k,j in valeur.items():
                if len(G[k])==3:
                    if (sommet7 in G[k]):
                        sommet11=k
                        break
    matgraph[11]=sommet11
    for cle,valeur in G.items():
        if cle==sommet8:
            for k,j in valeur.items():
                if len(G[k])==2:
                    sommet12=k
                    break
    matgraph[12]=sommet12
    for cle,valeur in G.items():
        if cle==sommet12:
            for k,j in valeur.items():
                if (sommet4 not in G[k]):
                    sommet13=k
                    break
    matgraph[13]=sommet13
    for cle,valeur in G.items():
        if cle==sommet13:
            for k,j in valeur.items():
                if len(G[k])==3:
                    sommet14=k
                    break
    matgraph[14]=sommet14
    for cle,valeur in G.items():
        if cle==sommet14:
            for k,j in valeur.items():
                if len(G[k])==2:
                    sommet15=k
                    break
    matgraph[15]=sommet15
    for cle,valeur in G.items():
        if cle==sommet0:
            for k,j in valeur.items():
                if k==sommet1:
                    poids0=j
                elif k==sommet4:
                    poids3=j
        elif cle==sommet1:
            for k,j in valeur.items():
                if k==sommet0:
                    poids0=j
                elif k==sommet5:
                    poids4=j
                elif k==sommet2:
                    poids1=j
        elif cle==sommet2:
            for k,j in valeur.items():
                if k==sommet1:
                    poids1=j
                elif k==sommet6:
                    poids5=j
                elif k==sommet3:
                    poids2=j
        elif cle==sommet3:
            for k,j in valeur.items():
                if k==sommet2:
                    poids2=j
                elif k==sommet7:
                    poids6=j
        elif cle==sommet4:
            for k,j in valeur.items():
                if k==sommet0:
                    poids3=j
                elif k==sommet5:
                    poids7=j
                elif k==sommet8:
                    poids10=j
        elif cle==sommet5:
            for k,j in valeur.items():
                if k==sommet1:
                    poids4=j
                elif k==sommet4:
                    poids7=j
                elif k==sommet6:
                    poids8=j
                elif k==sommet9:
                    poids11=j
        elif cle==sommet6:
            for k,j in valeur.items():
                if k==sommet2:
                    poids5=j
                elif k==sommet5:
                    poids8=j
                elif k==sommet7:
                    poids9=j
                elif k==sommet10:
                    poids12=j
        elif cle==sommet7:
            for k,j in valeur.items():
                if k==sommet3:
                    poids6=j
                elif k==sommet6:
                    poids9=j
                elif k==sommet11:
                    poids13=j
        elif cle==sommet8:
            for k,j in valeur.items():
                if k==sommet4:
                    poids10=j
                elif k==sommet9:
                    poids14=j
                elif k==sommet12:
                    poids17=j
        elif cle==sommet9:
            for k,j in valeur.items():
                if k==sommet8:
                    poids14=j
                elif k==sommet5:
                    poids11=j
                elif k==sommet13:
                    poids18=j
                elif k==sommet10:
                    poids15=j
        elif cle==sommet10:
            for k,j in valeur.items():
                if k==sommet9:
                    poids15=j
                elif k==sommet6:
                    poids12=j
                elif k==sommet14:
                    poids19=j
                elif k==sommet11:
                    poids16=j
        elif cle==sommet11:
            for k,j in valeur.items():
                if k==sommet10:
                    poids16=j
                elif k==sommet7:
                    poids13=j
                elif k==sommet15:
                    poids20=j
        elif cle==sommet12:
            for k,j in valeur.items():
                if k==sommet8:
                    poids17=j
                elif k==sommet13:
                    poids21=j
        elif cle==sommet13:
            for k,j in valeur.items():
                if k==sommet12:
                    poids21=j
                elif k==sommet9:
                    poids18=j
                elif k==sommet14:
                    poids22=j
        elif cle==sommet14:
            for k,j in valeur.items():
                if k==sommet13:
                    poids22=j
                elif k==sommet10:
                    poids19=j
                elif k==sommet15:
                    poids23=j
        elif cle==sommet15:
            for k,j in valeur.items():
                if k==sommet14:
                    poids23=j
                elif k==sommet11:
                    poids20=j  
    poids=[poids0,poids1,poids2,poids3,poids4,poids5,poids6,poids7,poids8,poids9,poids10,poids11,poids12,poids13,poids14,poids15,poids16,poids17,poids18,poids19,poids20,poids21,poids22,poids23] 
    Lmatgraph.append(matgraph)
    Lpoids.append(poids)
    return ""


def graph(G,départ,arrivé):
    '''
    Entrée: Dictionnaire G, str départ, str arrivé
    Sortie: Rien
    But: Afficher le graphe
    '''
    inddep=Lmatgraph[0].index(départ)
    indarr=Lmatgraph[0].index(arrivé)
    L=[]
    Ltrait=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    for k in Lpoids[0]:
        L.append(str(k))
    fig = plt.figure()
    ax = fig.add_subplot()
    w=3
    h=3
    rect1 = Rectangle((0,0), w, h, color="black")
    rect2 = Rectangle((0,5), w, h, color="black")
    rect3 = Rectangle((0,10), w, h, color="black")
    rect4 = Rectangle((0,15), w, h, color="black")

    rect5 = Rectangle((5,0), w, h, color="black")
    rect6 = Rectangle((5,5), w, h, color="black")
    rect7 = Rectangle((5,10), w, h, color="black")
    rect8 = Rectangle((5,15), w, h, color="black")

    rect9 = Rectangle((10,0), w, h, color="black")
    rect10 = Rectangle((10,5), w, h, color="black")
    rect11 = Rectangle((10,10), w, h, color="black")
    rect12 = Rectangle((10,15), w, h, color="black")
    
    rect13 = Rectangle((15,0), w, h, color="black")
    rect14 = Rectangle((15,5), w, h, color="black")
    rect15 = Rectangle((15,10), w, h, color="black")
    rect16 = Rectangle((15,15), w, h, color="black")
    
    ax.add_patch(rect1)
    ax.add_patch(rect2)
    ax.add_patch(rect3)
    ax.add_patch(rect4)
    ax.add_patch(rect5)
    ax.add_patch(rect6)
    ax.add_patch(rect7)
    ax.add_patch(rect8)
    ax.add_patch(rect9)
    ax.add_patch(rect10)
    ax.add_patch(rect11)
    ax.add_patch(rect12)
    ax.add_patch(rect13)
    ax.add_patch(rect14)
    ax.add_patch(rect15)
    ax.add_patch(rect16)
    
    if inddep==0:
        plt.scatter(1.5, 16.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==1:
        plt.scatter(6.5, 16.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==2:
        plt.scatter(11.5, 16.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==3:
        plt.scatter(16.5, 16.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==4:
        plt.scatter(1.5, 11.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==5:
        plt.scatter(6.5, 11.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==6:
        plt.scatter(11.5, 11.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==7:
        plt.scatter(16.5, 11.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==8:
        plt.scatter(1.5, 6.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==9:
        plt.scatter(6.5, 6.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==10:
        plt.scatter(11.5, 6.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==11:
        plt.scatter(16.5, 6.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==12:
        plt.scatter(1.5, 1.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==13:
        plt.scatter(6.5, 1.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==14:
        plt.scatter(11.5, 1.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')
    elif inddep==15:
        plt.scatter(16.5, 1.5,c='white',marker='s',s=200,label='Point de départ',edgecolors='black')

    if indarr==0:
        plt.scatter(1.5, 16.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==1:
        plt.scatter(6.5, 16.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==2:
        plt.scatter(11.5, 16.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==3:
        plt.scatter(16.5, 16.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==4:
        plt.scatter(1.5, 11.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==5:
        plt.scatter(6.5, 11.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==6:
        plt.scatter(11.5, 11.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==7:
        plt.scatter(16.5, 11.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==8:
        plt.scatter(1.5, 6.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==9:
        plt.scatter(6.5, 6.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==10:
        plt.scatter(11.5, 6.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==11:
        plt.scatter(16.5, 6.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==12:
        plt.scatter(1.5, 1.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==13:
        plt.scatter(6.5, 1.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==14:
        plt.scatter(11.5, 1.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')
    elif indarr==15:
        plt.scatter(16.5, 1.5,c='white',marker='X',s=400,label="Point d'arrivée",edgecolors='black')

    
    ta = np.array([[[ 3,  1.5],[5,   1.5]],
                   [[ 8,  1.5],[10,   1.5]],
                   [[ 13,  1.5],[15,   1.5]],
                   
                   [[ 3,  6.5],[5,   6.5]],
                   [[ 8,  6.5],[10,   6.5]],
                   [[ 13,  6.5],[15,   6.5]],
                   
                   [[ 3,  11.5],[5,   11.5]],
                   [[ 8,  11.5],[10,   11.5]],
                   [[ 13,  11.5],[15,   11.5]],
                   
                   [[ 3,  16.5],[5,   16.5]],
                   [[ 8,  16.5],[10,   16.5]],
                   [[ 13,  16.5],[15,   16.5]],
                   
                   [[ 1.5,  3],[1.5,   5]],
                   [[ 1.5,  8],[1.5,   10]],
                   [[ 1.5,  13],[1.5,   15]],
                   
                   [[ 6.5,  3],[6.5,   5]],
                   [[ 6.5,  8],[6.5,  10]],
                   [[ 6.5,  13],[6.5,   15]],
                   
                   [[ 11.5,  3],[11.5,  5]],
                   [[ 11.5,  8],[11.5,   10]],
                   [[ 11.5,  13],[11.5,   15]],
                   
                   [[ 16.5,  3],[16.5,   5]],
                   [[ 16.5,  8],[16.5,   10]],
                   [[ 16.5,  13],[16.5,   15]]]) 
    x, y = ta.T
    plt.text(3.9, 17, L[0], horizontalalignment = 'center', verticalalignment = 'center')
    plt.text(8.9, 17, L[1], horizontalalignment = 'center', verticalalignment = 'center') 
    plt.text(13.9, 17, L[2], horizontalalignment = 'center', verticalalignment = 'center') 
    
    plt.text(3.9, 12, L[7], horizontalalignment = 'center', verticalalignment = 'center') 
    plt.text(8.9, 12, L[8], horizontalalignment = 'center', verticalalignment = 'center') 
    plt.text(13.9, 12, L[9], horizontalalignment = 'center', verticalalignment = 'center') 
    
    plt.text(3.9, 7, L[14], horizontalalignment = 'center', verticalalignment = 'center') 
    plt.text(8.9, 7, L[15], horizontalalignment = 'center', verticalalignment = 'center') 
    plt.text(13.9, 7, L[16], horizontalalignment = 'center', verticalalignment = 'center')
    
    plt.text(3.9, 2, L[21], horizontalalignment = 'center', verticalalignment = 'center') 
    plt.text(8.9, 2, L[22], horizontalalignment = 'center', verticalalignment = 'center') 
    plt.text(13.9, 2, L[23], horizontalalignment = 'center', verticalalignment = 'center') 
    
    plt.text(1, 4, L[17], horizontalalignment = 'center', verticalalignment = 'center')
    plt.text(1, 9,L[10] , horizontalalignment = 'center', verticalalignment = 'center')
    plt.text(1, 14,L[3] , horizontalalignment = 'center', verticalalignment = 'center')
    
    plt.text(6, 4, L[18], horizontalalignment = 'center', verticalalignment = 'center')
    plt.text(6, 9, L[11], horizontalalignment = 'center', verticalalignment = 'center')
    plt.text(6, 14,L[4] , horizontalalignment = 'center', verticalalignment = 'center')
    
    plt.text(11, 4, L[19], horizontalalignment = 'center', verticalalignment = 'center')
    plt.text(11, 9, L[12], horizontalalignment = 'center', verticalalignment = 'center')
    plt.text(11, 14,L[5] , horizontalalignment = 'center', verticalalignment = 'center')
    
    plt.text(16, 4, L[20], horizontalalignment = 'center', verticalalignment = 'center')
    plt.text(16, 9, L[13], horizontalalignment = 'center', verticalalignment = 'center')
    plt.text(16, 14,L[6] , horizontalalignment = 'center', verticalalignment = 'center')
    
    plt.text(2.6, 15.4, Lmatgraph[0][0], horizontalalignment = 'center', verticalalignment = 'center',color="white")
    Ltrait[0]=[1.6,16.6]
    plt.text(2.6, 10.4,Lmatgraph[0][4] , horizontalalignment = 'center', verticalalignment = 'center',color="white") 
    Ltrait[4]=[1.6,11.6]
    plt.text(2.6, 5.4, Lmatgraph[0][8], horizontalalignment = 'center', verticalalignment = 'center',color="white")
    Ltrait[8]=[1.6,6.6]
    plt.text(2.6, 0.4, Lmatgraph[0][12], horizontalalignment = 'center', verticalalignment = 'center',color="white")
    Ltrait[12]=[1.6,1.6]
    
    plt.text(7.6, 15.4, Lmatgraph[0][1], horizontalalignment = 'center', verticalalignment = 'center',color="white") 
    Ltrait[1]=[6.6,16.6]
    plt.text(7.6, 10.4,Lmatgraph[0][5] , horizontalalignment = 'center', verticalalignment = 'center',color="white")
    Ltrait[5]=[6.6,11.6]
    plt.text(7.6, 5.4, Lmatgraph[0][9], horizontalalignment = 'center', verticalalignment = 'center',color="white") 
    Ltrait[9]=[6.6,6.6]
    plt.text(7.6, 0.4, Lmatgraph[0][13], horizontalalignment = 'center', verticalalignment = 'center',color="white") 
    Ltrait[13]=[6.6,1.6]
    
    plt.text(12.6, 15.4, Lmatgraph[0][2], horizontalalignment = 'center', verticalalignment = 'center',color="white") 
    Ltrait[2]=[11.6,16.6]
    plt.text(12.6, 10.4,Lmatgraph[0][6] , horizontalalignment = 'center', verticalalignment = 'center',color="white") 
    Ltrait[6]=[11.6,11.6]
    plt.text(12.6, 5.4, Lmatgraph[0][10], horizontalalignment = 'center', verticalalignment = 'center',color="white") 
    Ltrait[10]=[11.6,6.6]
    plt.text(12.6, 0.4, Lmatgraph[0][14], horizontalalignment = 'center', verticalalignment = 'center',color="white")
    Ltrait[14]=[11.6,1.6]
    
    plt.text(17.6, 15.4, Lmatgraph[0][3], horizontalalignment = 'center', verticalalignment = 'center',color="white") 
    Ltrait[3]=[16.6,16.6]
    plt.text(17.6, 10.4,Lmatgraph[0][7] , horizontalalignment = 'center', verticalalignment = 'center',color="white") 
    Ltrait[7]=[16.6,11.6]
    plt.text(17.6, 5.4, Lmatgraph[0][11], horizontalalignment = 'center', verticalalignment = 'center',color="white")
    Ltrait[11]=[16.6,6.6]
    plt.text(17.6, 0.4, Lmatgraph[0][15], horizontalalignment = 'center', verticalalignment = 'center',color="white") 
    Ltrait[15]=[16.6,1.6]
    
    for k in range(len(chemin[0])):
        x1=Ltrait[Lmatgraph[0].index(chemin[0][k])][0]
        y1=Ltrait[Lmatgraph[0].index(chemin[0][k])][1]
        x2=Ltrait[Lmatgraph[0].index(chemin[0][k+1])][0]
        y2=Ltrait[Lmatgraph[0].index(chemin[0][k+1])][1]
        if x1==x2:
            plt.plot([x1,x2],[min([y1,y2]),max([y1,y2])],color='red')
        elif y1==y2:
            plt.plot([min([x1,x2]),max([x1,x2])],[y1,y2],color='red')
        if chemin[0][k+1]==chemin[0][-1]:
            break
    
    plt.margins(0.005)
    plt.gcf().subplots_adjust(left = 0.3, bottom = 0.1, right = 0.9, top = 0.9, wspace = 0.9, hspace = 0.5)
    plt.plot(x, y, linewidth=2, color='black')
    #plt.legend(fontsize = 10)
    plt.axis('off')
    #plt.axis('equal')
    
    plt.show()
    return ""
</code></pre>
    <h3 id="sous-titre4" style="color:#515151"><br>Contrôle des moteurs</h3>
    <p>Le véhicule dispose de deux moteurs éléctriques. Afin de les contrôlers, on utilisera le module pymata4. En effet, à chaque utilisation d'un capteur ou actionneur, on devra placer la commande "board" avant chaque commande :</p>
    <pre class="line-numbers"><code class="language-python">
import random
from pymata4 import pymata4 
import time 

board =pymata4.Pymata4()

#Variables-Moteurs#
GA=10 #pin moteur gauche poleA (digital)
GB=5 #pin moteur gauche poleB   (digital)
DA=11 #pin moteur droit poleA  (digital)
DB=6 #pin moteur droit poleB  (digital)
HIGH=255 #Vitesse Max
LOW=0 #Vitesse nulle

def droite():     
    '''
    Entrée: Rien
    Sortie: Rien
    But: Faire tourner le véhicule dans le sens horaire
    '''
    board.pwm_write(DA,HIGH) #tourner à droite                                                       
    board.pwm_write(DB,LOW)                                                                          
    board.pwm_write(GA,LOW)                                                                          
    board.pwm_write(GB,HIGH)                                                                         
                                                                                                     
def arret():
    '''
    Entrée: Rien
    Sortie: Rien
    But: Arrêter le véhicule
    '''
    board.pwm_write(DA,LOW) #stop                                                                   
    board.pwm_write(DB,LOW)
    board.pwm_write(GA,LOW)
    board.pwm_write(GB,LOW)

def toutdroit():
    '''
    Entrée: Rien
    Sortie: Rien
    But: Faire avancerle véhicule tout droit 
    '''
    board.pwm_write(DA,LOW) #avancer tout droit
    board.pwm_write(DB,HIGH)
    board.pwm_write(GA,LOW)
    board.pwm_write(GB,HIGH)

def gauche():
    '''
    Entrée: Rien
    Sortie: Rien
    But: Faire tourner le véhicule dans le sens trigonométrique
    '''
    board.pwm_write(DA,LOW) #tourner à gauche
    board.pwm_write(DB,HIGH)
    board.pwm_write(GA,HIGH)
    board.pwm_write(GB,LOW)

def gauche90():
    '''
    Entrée: Rien
    Sortie: Rien
    But: Faire tourner le véhicule dans le sens trigonométrique de π/2
    '''
    gauche()
    time.sleep(0.7)
    arret()
    time.sleep(0.5)

def droite90():
    '''
    Entrée: Rien
    Sortie: Rien
    But: Faire tourner le véhicule dans le sens horaire de π/2
    '''
    droite()
    time.sleep(0.6)
    arret()
    time.sleep(0.5)

def r180():
    '''
    Entrée: Rien
    Sortie: Rien
    But: Faire tourner le véhicule dans le sens trigonométrique ou le sens horaire de π
    '''
    x=random.randint(0,1)
    if x==0:
        droite()
        time.sleep(1.3)
        arret()
        time.sleep(0.5)
    elif x==1:
        gauche()
        time.sleep(1.3)
        arret()
        time.sleep(0.5)
</code></pre>

    <h3 id="sous-titre5" style="color:#515151"><br>Suiveur de ligne</h3>
    <p>Le robot utilise deux capteurs infrarouges pour suivre une ligne noire tracée sur un fond blanc au sol, qui sert de guide pour le robot. Les capteurs permettent au robot de différencier la ligne noire de l'arrière-plan blanc. Lorsque les deux capteurs ne détectent pas la ligne, le robot continue d'avancer. Si l'un des capteurs détecte la ligne, le robot doit tourner dans la direction correspondante pour se placer au centre de la ligne (<a href=https://www.tutoriel-arduino.com/suiveur-de-ligne-arduino/>source</a>) :</p>
    <pre class="line-numbers"><code class="language-python">
#Variables-Capteurs infrarouges#
RIGHT=1 #pin capteur infrarouge droit (analog)
LEFT=0 #pin capteur infrarouge gauche (analog)

def gaucheb():
    board.pwm_write(DA,LOW) #avancer tout droit
    board.pwm_write(DB,HIGH)
    board.pwm_write(GA,LOW)
    board.pwm_write(GB,206)
    
def droiteb():
    board.pwm_write(DA,LOW) #avancer tout droit
    board.pwm_write(DB,206)
    board.pwm_write(GA,LOW)
    board.pwm_write(GB,HIGH)

def avancer():
    '''
    Entrée: Rien
    Sortie: Rien
    But: Maintenir le véhicule sur la ligne
    '''
    valeurIRd=[1,1]
    valeurIRg=[1,1]
    toutdroit()
    time.sleep(0.3)
    arret()
    time.sleep(0.5)
    a=sum(valeurIRd[-2:])/2
    b=sum(valeurIRg[-2:])/2
    c=a+b
    while (c<1000):
        valueD,time_stamp=board.analog_read(RIGHT)
        valeurIRd.append(valueD)
        valueG,time_stamp=board.analog_read(LEFT)
        valeurIRg.append(valueG)
        if (valeurIRd[-1]<=100) and (valeurIRg[-1]<=100):
            toutdroit()
        elif (valeurIRd[-1]<=100) and (valeurIRg[-1]>=100):
            gaucheb()
        elif (valeurIRd[-1]>=100) and (valeurIRg[-1]<=100):
            droiteb()
        else:
            break
        time.sleep(0.2)
        arret()
        #time.sleep(0.5)
    toutdroit()
    time.sleep(0.5)
    arret()
    time.sleep(0.5)
</code></pre>
    <p><br>Cependant, suivant la surface de contact ou le niveau de batterie du véhicule, il se peut que le véhicule ne soit pas dans la position souhaitée. C'est pourquoi, à l'aide d'un compas magnétique numérique, on pourra corriger sa position. Afin d'obtenir l'angle de direction, on s'aidera de deux fonctions :</p>
    <pre class="line-numbers"><code class="language-python">
import math

#boussole
declinationmagnetique=1 #Calibrage
Xmin =63001#Calibrage
Xmax =64469#Calibrage
Ymin =50105 #Calibrage
Ymax =51269#Calibrage
Xsf=(Ymax-Ymin)/(Xmax-Xmin) #Calibrage
Ysf=(Xmax-Xmin)/(Ymax-Ymin) #Calibrage
Xoff=(((Xmax-Xmin)/2)-Xmax)*Xsf #Calibrage
Yoff=(((Ymax-Ymin)/2)-Ymax)*Ysf #Calibrage
ang=[] #Liste des angles
X=[]
Y=[]

def the_call_back(data):
    """
    This is the callback function will return the Azimuth read from the device.
    :param data: [pin_type, Device address, device read register, x LSB, x MSB,
                  Y LSB, Y MSB, Z LSB, Z MSB]
    """
    # print the raw data returned
    #print(data)
    # indices into data to get values:
    x = data[3] + (data[4] << 8)
    y = data[5] + (data[6] << 8)
    # z = data[7] + (data[8] << 8)
    #X.append(x)
    #Y.append(y)
    x1=(x*Xsf)+Xoff
    y1=(y*Ysf)+Yoff
    X.append(x1)
    Y.append(y1)
    azimuth = (math.atan2(y1, x1) * 180.0 / math.pi)+declinationmagnetique
    if azimuth<0:
        azimuth+=360
    ang.append(azimuth)
    
def qmc5883l(my_board):
    """Renvoie l'angle de direction"""
    # device address = 13
    my_board.set_pin_mode_i2c()
    # initialize the qmc5883l
    # this is the equivalent of void QMC5883LCompass::init() in the library.
    # https://github.com/mprograms/QMC5883LCompass/blob/9f627ec5fcad7e7ddc15d7ed63c8bcc9ab940947/src/QMC5883LCompass.cpp#L69
    # write a value of 1 to register 0xb of the device
    # the first byte is the device address and next 2 bytes are what is being written
    # to the device. 11 is the 0xB register, and 1 is the value we are writing.
    my_board.i2c_write(13, [11, 1])
    time.sleep(.1)
    # now we need to set the device mode.
    # we will set the mode using the same values used by the Arduino library.
    MODE = 1
    ODR = 12  # output data rate
    RANGE = 16
    OSR = 0  # OVER_SAMPLE_RATION
    CONTROL_REGISTER_1 = 9
    MODE_DATA = MODE | ODR | RANGE | OSR
    # write the data to control register 1
    my_board.i2c_write(13, [CONTROL_REGISTER_1, MODE_DATA])
    time.sleep(.1)
    # read the xyz registers - data will be returned in the callback
    # the call back will calculate the azimuth
    my_board.i2c_read(13, 0, 6, the_call_back)
</code></pre>

    <p><br>On peut ainsi obtenir la liste des angles de direction des vecteurs X, -X, Y, -Y lorsque le véhicule sera initialiser :<p>
    <pre class="line-numbers"><code class="language-python">
vect=[0,0,0,0]#X;-X;Y;-Y #droite; gauche; haut; bas

def vecteur():
    '''
    Entrée: Rien
    Sortie: Rien
    But: Obtenir la liste des angles de direction des vecteurs X, -X, Y, -Y
    '''
    A=départ
    B=LVoisin[0]
    while len(ang)!=1:
        qmc5883l(board)
    if coordonnée(A)[0]==coordonnée(B)[0]:
        if coordonnée(A)[1]< coordonnée(B)[1]:
            vect[2]=ang[0]#Y
            vect[3]=ang[0]+180#-Y
            vect[0]=ang[0]+90#X
            vect[1]=ang[0]-90#-X
        else:
            vect[3]=ang[0]#-Y
            vect[2]=ang[0]+180#Y
            vect[0]=ang[0]-90#X
            vect[1]=ang[0]+90#-X
    elif coordonnée(A)[1]==coordonnée(B)[1]:
        if coordonnée(A)[0]< coordonnée(B)[0]:
            vect[0]=ang[0]#X
            vect[3]=ang[0]+90#-Y
            vect[2]=ang[0]-90#Y
            vect[1]=ang[0]+180#-X
        else:
            vect[1]=ang[0]#-X
            vect[3]=ang[0]-90#-Y
            vect[2]=ang[0]+90#Y
            vect[0]=ang[0]+180#X
    if vect[0]>360:
        vect[0]=vect[0]-360
    elif vect[0]<0:
        vect[0]=vect[0]+360
    if vect[1]>360:
        vect[1]=vect[1]-360
    elif vect[1]<0:
        vect[1]=vect[1]+360  
    if vect[2]>360:
        vect[2]=vect[0]-360
    elif vect[2]<0:
        vect[2]=vect[0]+360
    if vect[3]>360:
        vect[3]=vect[1]-360
    elif vect[3]<0:
        vect[3]=vect[1]+360
    return ""
</code></pre>

    <p><br>À présent, le script peut corriger la position du véhicule si celle-ci n'est pas correcte :</p>
    <pre class="line-numbers"><code class="language-python">
def detectDroite():
    '''
    Entrée: Rien
    Sortie: Rien
    But: Faire pivoter le véhicule dans le sens horaire jusqu'à ce qu'il retrouve la route
    '''
    detectD=[]
    valueD,time_stamp=board.analog_read(RIGHT)
    detectD.append(valueD)
    while detectD[-1]<=100:
        droiteb()
        valueD,time_stamp=board.analog_read(RIGHT)
        detectD.append(valueD)
    arret()
    time.sleep(0.5)
    return ""
    
def detectGauche():
    '''
    Entrée: Rien
    Sortie: Rien
    But: Faire pivoter le véhicule dans le sens trigonométrique jusqu'à ce qu'il retrouve la route
    '''
    detectG=[]
    valueG,time_stamp=board.analog_read(LEFT)
    detectG.append(valueG)
    while detectG[-1]<=100:
        gaucheb()
        valueG,time_stamp=board.analog_read(LEFT)
        detectG.append(valueG)
    arret()
    time.sleep(0.5)
    return ""
        

def correction():
    '''
    Entrée: Rien
    Sortie: Rien
    But: Si nécessaire, faire pivoter le véhicule jusqu'à ce qu'il retrouve la route
    '''
    c=20
    if Direction[-1]=="Haut":
        if ang[-1]>vect[2]:
            if abs(ang[-1]-vect[2])>=c:
                detectGauche()
        elif ang[-1]< vect[2]:
            if abs(ang[-1]-vect[2])>=c:
                detectDroite()
    elif Direction[-1]=="Bas":
        if ang[-1]>vect[3]:
            if abs(ang[-1]-vect[3])>=c:
                detectGauche()
        elif ang[-1]< vect[2]:
            if abs(ang[-1]-vect[3])>=c:
                detectDroite()
    elif Direction[-1]=="Droite":
        if ang[-1]>vect[0]:
            if abs(ang[-1]-vect[0])>=c:
                detectGauche()
        elif ang[-1]< vect[0]:
            if abs(ang[-1]-vect[0])>=c:
                detectDroite()
    elif Direction[-1]=="Gauche":
        if ang[-1]>vect[1]:
            if abs(ang[-1]-vect[1])>=c:
                detectGauche()
        elif ang[-1]< vect[1]:
            if abs(ang[-1]-vect[1])>=c:
                detectDroite()
    return ""
</code></pre>

    <h3 id="sous-titre6" style="color:#515151"><br>Initialisation du véhicule</h3>
    <p>Afin que le script connaisse la direction initiale du véhicule, on interroge l'utilisateur :</p>
    <pre class="line-numbers"><code class="language-python">
def manuelle(G):
    '''
    Entrée: dictionnaire G
    Sortie: Rien
    But: Initialiser le véhicule
    '''
    v=[]
    Voisin=0
    for cle,valeur in G.items():
        if cle==départ:
            for a,o in valeur.items():
                v.append(a)
    if len(v)==2:
        while True:
            Voisin=input(f"\nAfin d'initialiser votre véhicule autonome, orientez votre véhicule autonome vers un de ces sommets et indiquez votre choix:\n{v[0]} ou {v[1]}: ")
            if (Voisin==v[0]) or (Voisin==v[1]):
                break
    elif len(v)==3:
        while True:
            Voisin=input(f"\nAfin d'initialiser votre véhicule autonome, orientez votre véhicule autonome vers un de ces sommets et indiquez votre choix:\n{v[0]}, {v[1]} ou {v[2]}: ")
            if (Voisin==v[0]) or (Voisin==v[1]) or (Voisin==v[2]):
                break
    elif len(v)==4:
        while True:
            Voisin=input(f"\nAfin d'initialiser votre véhicule autonome, orientez votre véhicule autonome vers un de ces sommets et indiquez votre choix:\n{v[0]}, {v[1]}, {v[2]} ou {v[3]}: ")
            if (Voisin==v[0]) or (Voisin==v[1]) or (Voisin==v[2]) or (Voisin==v[3]):
                break
    LVoisin.append(Voisin)
    a=0
    while a!=" ":
        a=input("\nLorsque votre véhicule est orienté, cliquez une fois sur espace : ")
    return ""
</code></pre>

    <h3 id="sous-titre7" style="color:#515151"><br>Navigation</h3>
    <p>Tout d'abord, on doit instaurer un système de coordonnées :</p>
    <pre class="line-numbers"><code class="language-python">
def coordonnée(sommet):
    '''
    Entrée: Sommet str
    Sortie: Liste coord
    But: Retourner le coordonnée du sommet
    '''
    coord=[0,0]
    T = [Lmatgraph[0][idx: idx+4] for idx in range(0, 16, 4)]
    T[0],T[3]=T[3],T[0]
    T[1],T[2]=T[2],T[1]
    for k in T:
        for j in k:
            if j==sommet:
                coord[0]=k.index(j)
                coord[1]=T.index(k)
                break
    return coord 
</code></pre>    
    <p><br>Pour pouvoir naviguer, on se place dans une base X, Y, Z :</p>
    <div style="text-align: center;">
        <img src="img/principe_img2.png" height="475" width="475" alt="Description de l'image2">
    </div>
    <p>Ainsi, afin de diriger (X, -X, Y, -Y) le véhicule, le script effectue un calcul de coordonnée :</p>
    <pre class="line-numbers"><code class="language-python">
Direction=[]

def direction(A,B):
    '''
    Entrée: Sommets A,B str
    Sortie: Rien
    But: Déterminer dans quelle direction doit se diriger le véhicule X, -X, Y, -Y
    '''
    if coordonnée(A)[0]==coordonnée(B)[0]:
        if coordonnée(A)[1]< coordonnée(B)[1]:
            Direction.append("Haut") #Y
        else:
            Direction.append("Bas") #-Y
    elif coordonnée(A)[1]==coordonnée(B)[1]:
        if coordonnée(A)[0]< coordonnée(B)[0]:
            Direction.append("Droite") #X
        else:
            Direction.append("Gauche") #-X
    return ""
</code></pre>

    <p><br>Le script peut dès à présent déterminer le mouvement de rotation à effectuer afin que le véhicule soit dans la direction souhaitée. (En comparant la direction à l'instant t et celle souhaitée à l'instant t+1) :</p>
    <pre class="line-numbers"><code class="language-python">
mvm=[]

def mouvement():
    '''
    Entrée: Rien
    Sortie: Rien
    But: Déterminer le mouvement de rotation à effectuer afin que le véhicule soit dans la direction souhaitée
    '''
    if Direction[0]=="Haut":
        if Direction[1]=="Gauche":
            mvm.append("Gauche90")
        elif Direction[1]=="Droite":
            mvm.append("Droite90")
        elif Direction[1]=="Bas":
            mvm.append("R180")
        else:
            mvm.append("Rien")
    elif Direction[0]=="Bas":
        if Direction[1]=="Gauche":
            mvm.append("Droite90")
        elif Direction[1]=="Droite":
            mvm.append("Gauche90")
        elif Direction[1]=="Haut":
            mvm.append("R180")
        else:
            mvm.append("Rien")
    elif Direction[0]=="Gauche":
        if Direction[1]=="Bas":
            mvm.append("Gauche90")
        elif Direction[1]=="Droite":
            mvm.append("R180")
        elif Direction[1]=="Haut":
            mvm.append("Droite90") 
        else:
            mvm.append("Rien")
    elif Direction[0]=="Droite":
        if Direction[1]=="Bas":
            mvm.append("Droite90")
        elif Direction[1]=="Gauche":
            mvm.append("R180")
        elif Direction[1]=="Haut":
            mvm.append("Gauche90") 
        else:
            mvm.append("Rien")
    return ""
</code></pre>

    <h3 id="sous-titre8" style="color:#515151"><br>Éxecution des fonctions</h3>
    <p>Pour finir, le script peut exécuter les fonctions pour commencer le processus. De plus, si une route est bloquée, l'itinéraire est modifiée :</p>
    <pre class="line-numbers"><code class="language-python">
import sys

#Variables-Capteur de distance#
trig=9 #pin capteur ultrason (digital)
echo=8 #pin capteur ultrason (digital)
distance=[]

#Variables-Servomoteur#
Servo_pin = 4 #pin Servomoteur
anglec=90 #angle nulle
angled=0 #angle droite
angleg=180 #angle gauche

try:
    board.set_pin_mode_servo(Servo_pin)
    board.set_pin_mode_sonar(trig,echo)
    board.set_pin_mode_analog_input(RIGHT)
    board.set_pin_mode_analog_input(LEFT)
    board.set_pin_mode_pwm_output(GA)
    board.set_pin_mode_pwm_output(GB)
    board.set_pin_mode_pwm_output(DA)
    board.set_pin_mode_pwm_output(DB)
    time.sleep(1)
    #G=dictionnaire()
    G2=G.copy()
    départ=depart()
    arrivé=arrivée()
    matrice(G)
    affichage(G, départ, arrivé)
    print("\nVoici le graphe de votre circuit ! Le carré blanc est la position du véhicule, la croix blanche est le point d'arrivé. ")
    graph(G,départ,arrivé)
    manuelle(G)
    vecteur()
    direction(départ,LVoisin[0])
    direction(départ,chemin[0][1])
    mouvement()
    res=0
    print(f"\nVous êtes sur le sommet {chemin[0][0]}")
    while res==0:
        if mvm[0]=="R180":
            r180()
            board.servo_write(Servo_pin,anglec)
        elif mvm[0]=="Gauche90":
            board.servo_write(Servo_pin,angleg)
        elif mvm[0]=="Droite90":
            board.servo_write(Servo_pin,angled)
        elif mvm[0]=="Rien":
            board.servo_write(Servo_pin,anglec)
        time.sleep(1)
        while len(distance)<=3:
            (dist,temp)=board.sonar_read(trig)
            distance.append(dist)
        board.servo_write(Servo_pin,anglec)
        if distance[-1]>40:
            if mvm[0]=="Droite90":
                droite90()
                avancer()
            elif mvm[0]=="Gauche90":
                gauche90()
                avancer()
            elif mvm[0]=="R180":
                avancer()
            elif mvm[0]=="Rien":
                avancer()
            del(chemin[0][0])
            distance.clear()
            mvm.clear()
            del(Direction[0])
            res+=1
        else:
            if mvm[0]=="R180":
                r180()
            while res==0:
                print("\nCette route est bloquée, nous allons procéder à un changement d'itinéraire: ")
                for cle,valeur in G2.items():
                    if cle==chemin[0][0]:
                        for k,j in valeur.items():
                            if k==chemin[0][1]:
                                j=float('inf')
                Direction.clear()
                chemin2=chemin.copy()
                chemin.clear()
                affichage(G2,chemin2[0][0],arrivé)
                G2=G.copy()
                direction(départ,LVoisin[0])
                direction(départ,chemin[0][1])
                mouvement()
                if mvm[0]=="R180":
                    r180()
                    board.servo_write(Servo_pin,anglec)
                elif mvm[0]=="Gauche90":
                    board.servo_write(Servo_pin,angleg)
                elif mvm[0]=="Droite90":
                    board.servo_write(Servo_pin,angled)
                elif mvm[0]=="Rien":
                    board.servo_write(Servo_pin,anglec)
                time.sleep(1)
                while len(distance)<=3:
                    (dist,temp)=board.sonar_read(trig)
                    distance.append(dist)
                board.servo_write(Servo_pin,anglec)
                if distance[-1]>40:
                    if mvm[0]=="Droite90":
                        droite90()
                        avancer()
                    elif mvm[0]=="Gauche90":
                        gauche90()
                        avancer()
                    elif mvm[0]=="R180":
                        avancer()
                    elif mvm[0]=="Rien":
                        avancer()
                    del(chemin[0][0])
                    distance.clear()
                    mvm.clear()
                    del(Direction[0])
                    res+=1
                elif mvm[0]=="R180":
                    r180()
    while len(chemin[0])!=1:
        graph(G,chemin[0][0],arrivé)
        print(f"\nVous êtes sur le sommet {chemin[0][0]}")
        direction(chemin[0][0],chemin[0][1])
        mouvement()
        if mvm[0]=="R180":
            r180()
            board.servo_write(Servo_pin,anglec)
        elif mvm[0]=="Gauche90":
            board.servo_write(Servo_pin,angleg)
        elif mvm[0]=="Droite90":
            board.servo_write(Servo_pin,angled)
        elif mvm[0]=="Rien":
            board.servo_write(Servo_pin,anglec)
        time.sleep(1)
        while len(distance)<=3:
            (dist,temp)=board.sonar_read(trig)
            distance.append(dist)
        board.servo_write(Servo_pin,anglec)
        if distance[-1]>25:
            if mvm[0]=="Droite90":
                droite90()
                correction()
                avancer()
            elif mvm[0]=="Gauche90":
                gauche90()
                correction()
                avancer()
            elif mvm[0]=="R180":
                correction()
                avancer()
            elif mvm[0]=="Rien":
                correction()
                avancer()
            del(chemin[0][0])
            del(Direction[0])
        else:
            if mvm[0]=="R180":
                r180()
            print("\nCette route est bloquée, nous allons procéder à un changement d'itinéraire: ")
            for cle,valeur in G2.items():
                if cle==chemin[0][0]:
                    for k,j in valeur.items():
                        if k==chemin[0][1]:
                            j=float('inf')
            chemin2=chemin.copy()
            chemin.clear()
            affichage(G2,chemin2[0][0],arrivé)
            print("\nVoici le nouveau graphe de votre circuit ! Le carré blanc est le point de départ, la croix blanche est le point d'arrivé. ")
            graph(G,chemin[0][0],arrivé)
            G2=G.copy()
            del(Direction[1])
        distance.clear()
        mvm.clear()
    print("\nVous êtes arrivé à destination !") 
except KeyboardInterrupt: #ctrl+c
    arret()
    board.shutdown()
    sys.exit(0)
</code></pre>

        </ul>
    </main>
    <footer>
      <p>Copyright 2022 BAKIRI Yanis</p>
    </footer>
  <div id="scrollUp">
  <a href="#top"><img src="img/top.png"/></a>
  </div>
  </body>
</html>

